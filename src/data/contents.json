[
  {
    "content": "<a href=\"#結論\" class=\"heading-link\"><h2 id=\"結論\">結論</h2></a>\n<p>設定で <code>restoreMocks: true</code> を指定した方がいいです。</p>\n<p><a href=\"https://vitest.dev/config/#restoremocks\">https://vitest.dev/config/#restoremocks</a></p>\n<pre><span class=\"file-name\">vitest.config.ts</span><code class=\"language-ts:vitest.config.ts\">import { defineConfig } from 'vite';\n\nexport default defineConfig({\n  test: {\n    restoreMocks: true,\n  },\n});\n</code></pre>\n<p>やることは、<code>beforeEach</code> のタイミングで <code>vi.restoreAllMocks()</code> をしてくれるイメージです。<br>\n<code>vi.restoreAllMocks()</code>（あるいは <code>mock.mockRestore()</code>）は、call history をリセットし、かつ <code>vi.fn(impl)</code> の形式でモックした関数についてはその <code>impl</code> の振る舞いに戻ります。\nこれにより、<strong>誤って別の suite での呼び出しについて assertion してしまったり</strong>、<strong>振る舞いの変更が他の suite に影響を及ぼしたり</strong>するようなことを予め避けることができます。</p>\n<a href=\"#vitest-でのモックのリセット\" class=\"heading-link\"><h2 id=\"vitest-でのモックのリセット\">Vitest でのモックのリセット</h2></a>\n<p>Vitest（Jest でも同じようですが）では、モックのリセットに <code>reset</code>、<code>clear</code>、<code>restore</code> の 3 種類があり紛らわしいですが、<code>restore</code> が <code>reset</code>、<code>clear</code> で行うことを包含している形になっているので、基本的には <code>restoreMocks</code> の設定を有効にしておくのが良いかと思っています。\n詳しくはドキュメントを参照してください。</p>\n<a href=\"#どんな時に困るか\" class=\"heading-link\"><h2 id=\"どんな時に困るか\">どんな時に困るか</h2></a>\n<a href=\"#振る舞いの変更が他の-suite-に影響するケース\" class=\"heading-link\"><h3 id=\"振る舞いの変更が他の-suite-に影響するケース\">振る舞いの変更が他の suite に影響するケース</h3></a>\n<p>以下のようなテストコードを想定します。<br>\n別記事からの使い回しなので若干例として冗長ですが、ご了承ください。</p>\n<pre><span class=\"file-name\">user-profile.test.tsx</span><code class=\"language-tsx:user-profile.test.tsx\">import { render } from '@testing-library/react';\nimport { UserProfile } from './user-profile';\n\nconst { useUserQuery } = vi.hoisted(() =&gt; ({\n  useUserQuery: vi.fn(() =&gt; ({\n    data: { name: 'John Doe' },\n  })),\n}));\nvi.mock('./use-user-query', () =&gt; ({\n  useUserQuery,\n}));\n\ndescribe('UserProfile', () =&gt; {\n  it('ユーザー名が表示されること', () =&gt; {\n    const { getByText } = render(&lt;UserProfile /&gt;);\n    expect(getByText('John Doe')).toBeInTheDocument();\n  });\n\n  it('データが取得中の時、ローディング UI が表示されること', () =&gt; {\n    // モック関数の返り値を変更する\n    useUserQuery.mockReturnValue({\n      data: undefined,\n    });\n\n    const { getByText } = render(&lt;UserProfile /&gt;);\n    expect(getByText('Loading...')).toBeInTheDocument();\n  });\n\n  it('ユーザーページへのリンクが表示されること', () =&gt; {\n    const { getByRole } = render(&lt;UserProfile /&gt;);\n    expect(getByRole('link', { name: 'John Doe' })).toBeInTheDocument();\n  })\n});\n</code></pre>\n<p>上記の <code>'ユーザーページへのリンクが表示されること'</code> の suite は、useUserQuery が最初にモックされたままの実装であることを期待していますが、直前の suite 内の以下の箇所で <code>{ data: undefined }</code> を返す状態になってしまったままなので、リンクが表示されず fail します。</p>\n<pre><code class=\"language-ts\">useUserQuery.mockReturnValue({\n  data: undefined,\n});\n</code></pre>\n<p><code>restoreMocks</code> が有効である場合、<code>mockReturnValue()</code> によって加えられたモック関数への変更は、すべて初めに <code>vi.fn()</code> に渡した implementation に restore されるため、このような問題は起きません。</p>\n<a href=\"#呼び出し履歴が残ってしまっているケース\" class=\"heading-link\"><h3 id=\"呼び出し履歴が残ってしまっているケース\">呼び出し履歴が残ってしまっているケース</h3></a>\n<p>以下のようなテストは <code>restoreMocks</code> が有効でない場合 fail します。</p>\n<a href=\"#テスト対象\" class=\"heading-link\"><h2 id=\"テスト対象\">テスト対象</h2></a>\n<pre><span class=\"file-name\">show-toast-button.tsx</span><code class=\"language-tsx:show-toast-button.tsx\">import { useToast } from './use-toast';\n\ntype Props = {\n  disabled?: boolean;\n};\n\nexport function ShowToastButton({ disabled = false }: Props) {\n  const { showToast } = useToast();\n\n  const onClick = () =&gt; showToast('Hello!');\n\n  return (\n    &lt;button onClick={onClick} disabled={disabled}&gt;\n      Show Toast\n    &lt;/button&gt;\n  );\n}\n</code></pre>\n<a href=\"#テスト\" class=\"heading-link\"><h2 id=\"テスト\">テスト</h2></a>\n<pre><span class=\"file-name\">show-toast-button.test.tsx</span><code class=\"language-tsx:show-toast-button.test.tsx\">import { ShowToastButton } from './show-toast-button';\nimport userEvent from '@testing-library/user-event';\n\nconst { showToast } = vi.hoisted(() =&gt; ({\n  showToast: vi.fn(),\n}));\nvi.mock('./use-toast', () =&gt; ({\n  useToast: vi.fn(() =&gt; ({ showToast })),\n}));\n\ndescribe('ShowToastButton', () =&gt; {\n  it('ボタンがクリックされた時、トーストが表示されること', async () =&gt; {\n    const { getByRole } = render(&lt;ShowToastButton /&gt;);\n    await userEvent.click(getByRole('button', { name: 'Show Toast' }));\n    expect(showToast).toHaveBeenCalled();\n  });\n\n  it('disabled が true の時、クリックしてもトーストが表示されないこと', async () =&gt; {\n    const { getByRole } = render(&lt;ShowToastButton disabled /&gt;);\n    await userEvent.click(getByRole('button', { name: 'Show Toast' }));\n    expect(showToast).not.toHaveBeenCalled();\n  });\n});\n</code></pre>\n<pre><span class=\"file-name\">stdout</span><code class=\"language-shell:stdout\">AssertionError: expected \"spy\" to not be called at all, but actually been called 1 times\n</code></pre>\n<p><code>restoreMocks</code> が有効であれば、呼び出し履歴が suite ごとにリセットされるので、テストコードはそのままで pass します。</p>\n<a href=\"#都度-beforeeach-で書けばよいのでは\" class=\"heading-link\"><h3 id=\"都度-beforeeach-で書けばよいのでは\">都度 <code>beforeEach</code> で書けばよいのでは</h3></a>\n<p>こういうことが起こった / 起こりそうな時に、テストファイル単位で以下を記載する、でも良いのかもしれませんが、基本的にはこのような変更が suite 間で共有されることを期待することはないと思うので、全体の設定で良いと思っています。</p>\n<pre><code class=\"language-ts\">beforeEach(() =&gt; {\n  vi.restoreAllMocks();\n});\n</code></pre>\n<a href=\"#restoremocks:-true-にしたらこれまでのテストが壊れたが？\" class=\"heading-link\"><h2 id=\"restoremocks:-true-にしたらこれまでのテストが壊れたが？\"><code>restoreMocks: true</code> にしたらこれまでのテストが壊れたが？</h2></a>\n<p>suite 記載外のモック関数の変更が保持されていることを期待するテストについては、挙動が変わるので落ちます。<br>\n大きいプロジェクトで、落ちるテストも多いと設定の変更はなかなか難しいと思うので、取り急ぎ新しく書くファイルについては以下のようにファイル単位で設定してしまう、でも良いかと思います。<code>vi.setConfig()</code> のスコープはファイルなので、他に影響しません。</p>\n<pre><code class=\"language-ts\">vi.setConfig({ restoreMocks: true });\n</code></pre>",
    "meta": {
      "slug": "vitest-restore-mocks",
      "title": "Vitest の restoreMocks はとりあえず true でいいと思います",
      "publishedAt": "2023-12-29",
      "tags": [
        "vitest",
        "testing"
      ]
    }
  },
  {
    "content": "<p>公式ドキュメント<br>\n<a href=\"https://beta.nextjs.org/docs/routing/route-handlers\">Routing: Route Handlers | Next.js</a></p>\n<a href=\"#tldr\" class=\"heading-link\"><h2 id=\"tldr\">tldr</h2></a>\n<p>これまで <code>pages</code> directory では例えば <strong><code>/pages/api/hello.ts</code></strong> を作成して以下のように書いていましたが、</p>\n<pre><span class=\"file-name\">pages/api/hello.ts</span><code class=\"language-typescript:pages/api/hello.ts\">export default function handler(req, res) {\n  res.json({ msg: 'Hello world!' });\n}\n</code></pre>\n<p><code>app</code> directory で同じことをする場合は、<strong><code>/app/hello/route.ts</code></strong> を作成して以下のように書きます。</p>\n<pre><span class=\"file-name\">app/hello/route.ts</span><code class=\"language-typescript:app/hello/route.ts\">export function GET(req) {\n  return new Response('Hello world!');\n}\n</code></pre>\n<a href=\"#変わったこと\" class=\"heading-link\"><h2 id=\"変わったこと\">変わったこと</h2></a>\n<p>それぞれのインターフェース変更についての細かい意思決定プロセスは全く追っていませんが、ひとまず表面的には以下のような変更があります。</p>\n<p><a href=\"#%E7%89%B9%E5%AE%9A%E3%81%AE%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%81%AB%E5%AF%BE%E3%81%97%E3%81%A6%E3%81%AE%E3%83%8F%E3%83%B3%E3%83%89%E3%83%A9%E3%82%92-named-export-%E3%81%99%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%AA%E3%81%A3%E3%81%9F\">1. 特定のメソッドに対してのハンドラを named export するようになった</a></p>\n<p><a href=\"#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E7%BD%AE%E3%81%8F%E5%A0%B4%E6%89%80%E3%81%8C%E5%A4%89%E3%82%8F%E3%81%A3%E3%81%9F\">2. ファイルを置く場所が変わった</a></p>\n<p><a href=\"#%E3%83%8F%E3%83%B3%E3%83%89%E3%83%A9%E3%81%AE-api-%E3%81%8C%E5%A4%89%E3%82%8F%E3%81%A3%E3%81%9F\">3. ハンドラの API が変わった</a></p>\n<a href=\"#特定のメソッドに対してのハンドラを-named-export-するようになった\" class=\"heading-link\"><h3 id=\"特定のメソッドに対してのハンドラを-named-export-するようになった\">特定のメソッドに対してのハンドラを named export するようになった</h3></a>\n<p>これまで全ての HTTP method に default export されたハンドラが割り当てられていましたが、<code>GET</code> や <code>POST</code> のように特定のメソッドに対してのハンドラを named export するように変更されました。<br>\n<a href=\"https://beta.nextjs.org/docs/routing/route-handlers#supported-http-methods\">Supported HTTP Methods | Next.js</a></p>\n<p>大抵 (というか全て) API は特定の method のみを想定しているはずなので、これまで実装者は以下のような分岐を書く必要がありました。</p>\n<pre><code class=\"language-typescript\">export default function handler(req, res) {\n  if (req.method !== 'POST') {\n    res.status(403).json({ error: 'Method not allowed' });\n  }\n}\n</code></pre>\n<p>これを愚直に書いていたか、ある程度共通化していたか、うまいことミドルウェアを噛ませていたかはさておき、単純に嬉しい update かと思います。</p>\n<a href=\"#ファイルを置く場所が変わった\" class=\"heading-link\"><h3 id=\"ファイルを置く場所が変わった\">ファイルを置く場所が変わった</h3></a>\n<p><a href=\"https://beta.nextjs.org/docs/routing/fundamentals\"><code>app</code> directory 自体の変更</a>と言えますが、ファイルを置く場所が <code>/pages/api/**/*.tsx</code> から、<code>/app/**/route.tsx</code> に変わりました。<br>\n例えば <code>/api/posts</code> のエンドポイントはこれまで <strong><code>/pages/api/posts/index.tsx</code></strong> に置いていたファイルは、<strong><code>/app/posts/route.tsx</code></strong> に置くようになります。</p>\n<a href=\"#ハンドラの-api-が変わった\" class=\"heading-link\"><h3 id=\"ハンドラの-api-が変わった\">ハンドラの API が変わった</h3></a>\n<p>これまでの <code>NextApiHandler</code> は比較的 express like で、<code>req</code> と <code>res</code> を受け取り、<code>res.json()</code> などでレスポンスしていました。<br>\nRoute Handlers ではよりローレベル / ブラウザネイティブな API が露出していて、<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Request\">Fetch API の Request</a> を受け取り、関数から <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Response\">Fetch API の Response</a> を返します。</p>\n<p>ただし、より easy に Next.js がラップした便利 <code>req: NextRequest</code>、<code>res: NextResponse</code> を引き続き使うこともできるそうです。<br>\n<a href=\"https://beta.nextjs.org/docs/routing/route-handlers#extended-nextrequest-and-nextresponse-apis\">Extended NextRequest and NextResponse APIs | Next.js</a></p>\n<p>以下は Next.js の docs から引用しました。</p>\n<pre><code class=\"language-typescript\">export async function GET(request: NextRequest) {\n  const token = request.cookies.get('token');\n  const response = NextResponse.next();\n  response.cookies.set('token', token);\n  return response;\n}\n</code></pre>\n<a href=\"#以上です\" class=\"heading-link\"><h2 id=\"以上です\">以上です</h2></a>\n<p>大体こんな感じでしょうか？</p>",
    "meta": {
      "slug": "route-handlers",
      "title": "appDir の Route Handlers を使う・API Routes からの変更点",
      "publishedAt": "2023-04-22",
      "tags": [
        "nextjs"
      ]
    }
  }
]
